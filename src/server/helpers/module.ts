import * as logger from 'next/dist/build/output/log.js';
import type NextNodeServer from 'next/dist/server/next-server.js';
import type { SocketHandler, UpgradeHandler } from './socket.js';

/**
 * Imports the route module for a given file path.
 * @param nextServer Next.js Node server instance
 * @param filePathname File path
 * @returns Route module if existing
 */
export async function importRouteModule(
  nextServer: NextNodeServer,
  filePathname: string,
) {
  try {
    // CHANGE(next@14): hotReloader was removed and ensurePage was moved to NextNodeServer
    if ('hotReloader' in nextServer) {
      // @ts-expect-error - hotReloader only exists in Next.js 13
      await nextServer.hotReloader?.ensurePage({
        page: filePathname,
        clientOnly: false,
      });
    } else if ('ensurePage' in nextServer) {
      // ensurePage throws an error in production, so we need to catch it
      // @ts-expect-error - ensurePage is protected
      await nextServer.ensurePage({ page: filePathname, clientOnly: false });
    } else {
      // Future-proofing
      logger.warnOnce(
        '[next-ws] unable to ensure page, you may need to open the route in your browser first so Next.js compiles it',
      );
    }
  } catch {}

  try {
    // @ts-expect-error - getPageModule is protected
    const buildPagePath = nextServer.getPagePath(filePathname);
    return (await require(buildPagePath)).routeModule as RouteModule;
  } catch (cause) {
    console.error(cause);
    return undefined;
  }
}

/**
 * Route module, generated by Next.js.
 */
export interface RouteModule {
  userland: {
    /** @deprecated Prefer UPGRADE and {@link UpgradeHandler} */
    SOCKET?: SocketHandler;
    UPGRADE?: UpgradeHandler;
  };
}

/**
 * Extract the parameters from a route pattern.
 */
export type RouteParams<Pattern extends string> =
  Pattern extends `${infer Before}[[...${infer Param}]]${infer After}`
    ? RouteParams<Before> & { [K in Param]?: string[] } & RouteParams<After>
    : Pattern extends `${infer Before}[...${infer Param}]${infer After}`
      ? RouteParams<Before> & { [K in Param]: string[] } & RouteParams<After>
      : Pattern extends `${infer Before}[${infer Param}]${infer After}`
        ? RouteParams<Before> & { [K in Param]: string } & RouteParams<After>
        : // biome-ignore lint/complexity/noBannedTypes: do nothing
          {};

/**
 * Route context object containing the parameters.
 */
export type RouteContext<Path extends string> = {
  params: Record<string, string | string[] | undefined> &
    RouteParams<Path> &
    RouteParams<Path>;
};
